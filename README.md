# DesignCode15

<img src="https://github.com/ihValery/DesignCode15/blob/main/Image/headerPreView.png?raw=true"></a>

- Закругления в стиле iOS
    - .mask(RoundedRectangle(cornerRadius: GlobalConstant.Corner.card, style: .continuous))
    - mask на подобии корнерРадиус но + можно и дальше модифицировать (.opacity)
    - style: .continuous - Непрерывная кривизна закругленных прямоугольных углов.

- Градиент на текст
        - .foregroundStyle(.linearGradient(colors: [.red, .blue],
        - startPoint: .topLeading, endPoint: .bottomTrailing))

- Canvas(холст) - рисование фигур вместо импорта картинок, может обеспечить лучшую производительность для сложного чертежа.
        - [SVG to SwiftUI](https://quassum.github.io/SVG-to-SwiftUI/)
        - TimelineView

- .spring(response: Double, скорость в начале
        - dampingFraction: Double, затухание - насколько быстро она происходит
        - blendDuration: Double длительность смешивания

- Matched Geometry Effect
    - Namespace нам потребовался один
    - Итак, есть несколько правил, которые вы должны понять, прежде чем двигаться дальше. И это потребует практики:
        - Первый эффект сопоставленной геометрии должен использоваться на отдельных элементах, даже включая цвет, все, что является стилизацией, должно использовать этот модификатор. Это не очень хорошая идея использовать его на VStack или после кадра, особенно когда происходит изменение положения или размера, как, например, в случае со шрифтом.
        - Во-вторых, отдельные элементы должны сохранять целостность в плане стилизации, если это не влияет на размер или положение. Поэтому целостность должна быть выполнена до модификатора, а позиционирование - после. Далее, когда вы измените порядок этих элементов, они будут работать просто отлично.
        - И, наконец, когда вы не применяете эффект совпадения геометрии, он просто вернется к стандартному переходу, который будет представлять собой затухание элемента. Например, если это цвет фона, то он просто покажет или скроет новый вид сверху, а затем обратно и вперед.

- Namespace
    - @Namespace private var namespace - привязку реализуем через var namespace: Namespace.ID
    - чтобы из коллекции указать уникальный ID 
        - .matchedGeometryEffect(id: "title\(course.id)", in: namespace)
